{%- set func_name = "_" + app_name|ident -%}
{%- set scope = "" -%}

{#- macro def -#}
{%- macro output_log(logfile) -%}
{%- if logfile is not none %}
  echo "COMP_LINE: $COMP_LINE" >> {{ logfile }}
  echo "COMP_POINT: $COMP_POINT" >> {{ logfile }}
  echo "COMP_CWORD: $COMP_CWORD" >> {{ logfile }}
  echo "COMP_WORDS: ${COMP_WORDS[@]}" >> {{ logfile }}
  echo "COMPREPLY: ${COMPREPLY[@]}" >> {{ logfile }}
  echo >> {{ logfile }}
{%- endif %}
{%- endmacro -%}
{%- macro argument_completion(argument) -%}
{% if argument.type == "select" -%}
if [ $cword -eq $COMP_CWORD ] ; then
  COMPREPLY=( $(compgen -W "{{ argument.options|join(" ") }}" -- "${COMP_WORDS[COMP_CWORD]}") )
  {{- output_log(logfile) }}
  return 0
else
  cmd_cword=$(( cmd_cword + 2 ))
fi
{%- elif argument.type == "file" -%}
if [ $cword -eq $COMP_CWORD ] ; then
{%- if argument.base_path is none %}
  word="${COMP_WORDS[COMP_CWORD]}"
{%- else %}
  word="{{ argument.base_path }}/${COMP_WORDS[COMP_CWORD]}"
{%- endif %}
  COMPREPLY=()
  for dir in $(compgen -d -S / -- "$word"); do
    COMPREPLY+=("$dir")
  done
  for file in $(compgen -f -- "$word"); do
    [ ! -d $file ] && COMPREPLY+=("$file")
  done

{%- if argument.base_path is none %}
  IFS=$'\n' COMPREPLY=($(sort <<<"${COMPREPLY[*]}"))
{%- else %}
  IFS=$'\n' COMPREPLY=($(sort <<<"${COMPREPLY[*]#{{ argument.base_path }}/}"))
{%- endif %}
  {{- output_log(logfile) }}
  return 0
else
  cmd_cword=$(( cmd_cword + 2 ))
fi
{%- elif argument.type == "command" -%}
if [ $cword -eq $COMP_CWORD ] ; then
  COMPREPLY=( $(compgen -W "$({{ argument.execute }})" -- "${COMP_WORDS[COMP_CWORD]}") )
  {{- output_log(logfile) }}
  return 0
else
  cmd_cword=$(( cmd_cword + 2 ))
fi
{%- elif argument.type == "flag" -%}
cmd_cword=$(( cmd_cword + 1 ))
{%- endif -%}
{%- endmacro -%}

{#- macro def -#}
{%- macro command_completion(command, depth) -%}
cmd_cword=$cword
while [ $cword -lt $COMP_CWORD ] ; do
  cword=$(( cword + 1 ))

{%- if command.has_keyword_arguments %}
  case "${COMP_WORDS[cword-1]}" in
{%- for keyword, argument in command.keyword_arguments.items() %}
    {{ ([keyword] + argument.aliases)|join("|") }})
      {{ argument_completion(argument)|indent(6) }}
      ;;
{% endfor %}
    *)
      break
      ;;
  esac
{%- endif %}
done
{%- if command.has_positional_arguments %}
if [[ ! ${COMP_WORDS[COMP_CWORD]} == -* ]] ; then
  cword=$COMP_CWORD
  case $(( COMP_CWORD - cmd_cword + 1)) in
  {%- for position, argument in command.positional_arguments.items() %}
    {{ position }})
      {{ argument_completion(argument)|indent(4) }}
      ;;
  {% endfor -%}
  esac
fi
{%- endif %}

{% if command.type == "delegate" -%}
{%- if command.has_keyword_arguments -%}
local has_keyword_splitter=false
for word in ${COMP_WORDS[@]::$COMP_CWORD}; do
  [ "$word" == "--" ] && has_keyword_splitter=true && break
done
if [[ $has_keyword_splitter = false && ${COMP_WORDS[COMP_CWORD]} == -* ]] ; then
  opts="{{ command.keyword_names_with_alias|join(' ') }}"
  COMPREPLY=( $(compgen -W "${opts}" -- "${COMP_WORDS[COMP_CWORD]}") )
  {{- output_log(logfile) }}
  return 0
fi
{% endif -%}
local word=${COMP_WORDS[@]::$cmd_cword}
COMP_POINT=$((COMP_POINT + {{ command.targets | join(" ") | length }} - {{ "${#word}" }} ))
COMP_LINE="{{ command.targets | join(' ') }} ${COMP_WORDS[@]:$cmd_cword}"
COMP_WORDS=($COMP_LINE)
COMP_CWORD=$(( {{ "${#COMP_WORDS[@]}" }} - 1 ))
(( COMP_CWORD < 1 )) && COMP_CWORD=1

type "_command_offset" > /dev/null 2>&1 && _command_offset 0
{%- elif command.has_subcommands -%}
if [[ ${COMP_WORDS[COMP_CWORD]} == -* ]] ; then
  opts="{{ command.keyword_names_with_alias|join(' ') }}"
  COMPREPLY=( $(compgen -W "${opts}" -- "${COMP_WORDS[COMP_CWORD]}") )
  {{- output_log(logfile) }}
  return 0
elif [ $cword -eq $COMP_CWORD ] ; then
  opts="{{ command.subcommand_names_with_alias|join(' ') }}"
  COMPREPLY=( $(compgen -W "${opts}" -- "${COMP_WORDS[COMP_CWORD]}") )
  {{- output_log(logfile) }}
  return 0
fi
{%- elif command.has_positional_arguments or command.has_positional_wildcard_argument -%}
if [[ ${COMP_WORDS[COMP_CWORD]} == -* ]] ; then
  opts="{{ command.keyword_names_with_alias|join(' ') }}"
  COMPREPLY=( $(compgen -W "${opts}" -- "${COMP_WORDS[COMP_CWORD]}") )
  {{- output_log(logfile) }}
  return 0
fi
{%- else -%}
opts="{{ command.keyword_names_with_alias|join(' ') }}"
COMPREPLY=( $(compgen -W "${opts}" -- "${COMP_WORDS[COMP_CWORD]}") )
{%- endif %}

{%- if command.has_positional_wildcard_argument %}
cword=$COMP_CWORD
{{ argument_completion(command.positional_wildcard_argument) }}
{%- endif %}
{%- endmacro -%}


#!/bin/bash
#
# Code generated by cmdcomp "{{ version }}". DO NOT EDIT.
# For more information about cmdcomp, please refer to https://github.com/yassun7010/cmdcomp .
#

{{ func_name }}() {
  local word cmd opts cword cmd_cword opts_cword
  COMPREPLY=()
  cmd=""
  opts=""
  cword=0
  cmd_cword=0
  opts_cword=0

  for word in ${COMP_WORDS[@]}; do
    case "${cmd},${word}" in
      ",$1")
        cmd="{{ func_name }}"
        cword=$(( cword + opts_cword + 1 ))
        ;;
{% for (tag, command_name), subcommand in append_key_tag(commands[app_name].subcommands, func_name).items() recursive %}
      {%- set new_tag = tag + "_" + command_name|ident %}
      {{ tag }},{{ command_name }}
{%- for alias in subcommand.aliases -%}
      |{{ tag }},{{ alias }}
{%- endfor -%})
        cmd="{{ new_tag }}"
        cword=$(( cword + opts_cword + 1 ))
        ;;
{{ loop(append_key_tag(subcommand.subcommands, new_tag).items()) -}}
{% endfor %}
      *)
        opts_cword=$(( opts_cword + 1 ))
        ;;
    esac
  done

  case "${cmd}" in
    {{ func_name }})
      {{ command_completion(commands[app_name], 1)|indent(6) }}
      {{- output_log(logfile) }}
      return 0
      ;;
{% for (tag, command_name), subcommand in append_key_tag(commands[app_name].subcommands, func_name).items() recursive %}
{%- set new_tag = tag + "_" + command_name|ident %}
    {{ new_tag }})
      {{ command_completion(subcommand, loop.depth + 1)|indent(6) }}
      {{- output_log(logfile) }}
      return 0
      ;;
{{ loop(append_key_tag(subcommand.subcommands, new_tag).items()) -}}
{% endfor %}
  esac
}

complete -F {{ func_name }} -o bashdefault {{ app_name }}
{%- for alias in app_aliases %}
complete -F {{ func_name }} -o bashdefault {{ alias }}
{%- endfor -%}
